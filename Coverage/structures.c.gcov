        -:    0:Source:../structures.c
        -:    0:Programs:3
        -:    1:#ifndef STRUCTURES_H
        -:    2:#include "structures.h"
        -:    3:#endif
        -:    4:
    #####:    5:void addToIntMapping(IndexMapping *mapping, int ind) {
    #####:    6:	iladd(&(mapping->inds), ind);
    #####:    7:}
        -:    8:
    #####:    9:IndexList* emptyILL() {
    #####:   10:	IndexList* pll = (IndexList*) calloc(1, sizeof(IndexList));
    #####:   11:}
        -:   12:
      234:   13:IndexList evaluate(IndexMap *map, float point) {
      234:   14:	IndexMapping *cur = *map;
     1827:   15:	while (cur != NULL) {
     1530:   16:		if (cur->point == point) {
      171:   17:			return cur->inds;
        -:   18:		}
     1359:   19:		cur = cur->next;
        -:   20:	}
       63:   21:	return NULL;
        -:   22:}
        -:   23:
       20:   24:IndexList* newil(int value) {
       20:   25:	IndexList *ill = (IndexList*) calloc(1, sizeof(IndexList));
       20:   26:	*ill = newiln(value);
       20:   27:	return ill;
        -:   28:}
        -:   29:
        -:   30:/**
        -:   31: * Add a value to a sorted list.  Returns a pointer to the node added
        -:   32: */
    #####:   33:IndexListNode* iladd(IndexList *ill, int value) {
    #####:   34:	IndexListNode *node = newiln(value), *cur = *ill, *last = cur;
    #####:   35:	if (cur == NULL) {
    #####:   36:		*ill = node;
    #####:   37:		return node;
        -:   38:	}
    #####:   39:	else if (value == cur->value) {
    #####:   40:		return cur;
        -:   41:	}
    #####:   42:	else if (value < cur->value) {
        -:   43:		// If the value is lower than the first in the list
    #####:   44:		node->next = cur;
    #####:   45:		*ill = node;
    #####:   46:		return node;
        -:   47:	}
    #####:   48:	while (cur != NULL && cur->value < value) {
    #####:   49:		last = cur;
    #####:   50:		cur = cur->next;
        -:   51:	}
    #####:   52:	if (cur == NULL) {
        -:   53:		// The value is larger than the values in the list
    #####:   54:		last->next = node;
    #####:   55:		return node;
        -:   56:	}
    #####:   57:	else if (cur->value == value) {
        -:   58:		// The value is equal to the current value
    #####:   59:		return cur;
        -:   60:	}
        -:   61:	else {
        -:   62:		// The value is greater than the last and less than the current
    #####:   63:		last->next = node;
    #####:   64:		node->next = cur;
    #####:   65:		return node;
        -:   66:	}
        -:   67:}
        -:   68:
    #####:   69:void ilfree(IndexList *ill) {
    #####:   70:	IndexListNode *node = *ill, *last = NULL;
    #####:   71:	while (node != NULL) {
    #####:   72:		last = node;
    #####:   73:		node = node->next;
    #####:   74:		free(last);
        -:   75:	}
    #####:   76:	free(ill);
    #####:   77:}
        -:   78:
        -:   79:/**
        -:   80: * Add a value to a sorted list.  Returns a pointer to the node added
        -:   81: */
       20:   82:IndexMapping* imadd(IndexMap *map, float point, int ind) {
       20:   83:	IndexMapping *mapping = newIndexMapping(point, ind), *cur = *map, *last = NULL;
      112:   84:	while (cur != NULL && cur->point < point) {
       72:   85:		last = cur;
       72:   86:		cur = cur->next;
        -:   87:	}
       20:   88:	if (cur == NULL) {
        -:   89:		// The value is larger than the values in the list
       10:   90:		if (last == NULL) {
        2:   91:			*map = mapping;
        2:   92:			return mapping;
        -:   93:		}
        8:   94:		last->next = mapping;
        8:   95:		return mapping;
        -:   96:	}
       10:   97:	else if (cur->point == point) {
        -:   98:		// The value is equal to the current value
    #####:   99:		iladd(&(cur->inds), ind);
    #####:  100:		return cur;
        -:  101:	}
        -:  102:	else {
        -:  103:		// The value is greater than the last and less than the current
       10:  104:		if (last == NULL) {
    #####:  105:			mapping->next = *map;
    #####:  106:			*map = mapping;
    #####:  107:			return mapping;
        -:  108:		}
       10:  109:		last->next = mapping;
       10:  110:		mapping->next = cur;
       10:  111:		return mapping;
        -:  112:	}
        -:  113:}
        -:  114:
        2:  115:void imfree(IndexMap *map) {
        2:  116:	IndexMapping *node = *map, *last = NULL;
       24:  117:	while (node != NULL) {
       20:  118:		last = node;
       20:  119:		node = node->next;
       20:  120:		free(last);
        -:  121:	}
        2:  122:	free(map);
        2:  123:}
        -:  124:
        -:  125:// Does this function need to be here?
       20:  126:IndexListNode* newiln(int value) {
       20:  127:	IndexListNode *iln = (IndexListNode*) calloc(1, sizeof(IndexListNode));
       20:  128:	iln->value = value;
       20:  129:	return iln;
        -:  130:}
        -:  131:
       20:  132:IndexMapping* newIndexMapping(float point, int ind) {
       20:  133:	IndexMapping *mapping = (IndexMapping*) calloc(1, sizeof(IndexMapping));
       20:  134:	mapping->point = point;
       20:  135:	mapping->inds = *newil(ind);
       20:  136:	return mapping;
        -:  137:}
        -:  138:
        2:  139:IndexMap* newim() {
        2:  140:	IndexMap* map = (IndexMap*) calloc(1, sizeof(IndexMap));
        2:  141:}
        -:  142:
        2:  143:PointList* newpl() {
        2:  144:	PointList *pll = (PointList*) calloc(1, sizeof(PointList));
        2:  145:}
        -:  146:
       30:  147:PointListNode* newpln(float value) {
       30:  148:	PointListNode *pln = (PointListNode*) calloc(1, sizeof(PointListNode));
       30:  149:	pln->value = value;
       30:  150:	return pln;
        -:  151:}
        -:  152:
        -:  153:/**
        -:  154: * Add a value to a sorted list.  Returns a pointer to the node added
        -:  155: */
       30:  156:PointListNode* pladd(PointList *pll, float value) {
       30:  157:	PointListNode *node = newpln(value), *cur = *pll, *last = cur;
       30:  158:	if (cur == NULL) {
        2:  159:		*pll = node;
        2:  160:		return node;
        -:  161:	}
       28:  162:	else if (value == cur->value) {
    #####:  163:		return cur;
        -:  164:	}
       28:  165:	else if (value < cur->value) {
        -:  166:		// If the value is lower than the first in the list
        1:  167:		node->next = cur;
        1:  168:		*pll = node;
        1:  169:		return node;
        -:  170:	}
      182:  171:	while (cur != NULL && cur->value < value) {
      128:  172:		last = cur;
      128:  173:		cur = cur->next;
        -:  174:	}
       27:  175:	if (cur == NULL) {
        -:  176:		// The value is larger than the values in the list
        6:  177:		last->next = node;
        6:  178:		return node;
        -:  179:	}
       21:  180:	else if (cur->value == value) {
        -:  181:		// The value is equal to the current value
        7:  182:		return cur;
        -:  183:	}
        -:  184:	else {
        -:  185:		// The value is greater than the last and less than the current
       14:  186:		last->next = node;
       14:  187:		node->next = cur;
       14:  188:		return node;
        -:  189:	}
        -:  190:}
        -:  191:
        2:  192:void plfree(PointList *pll) {
        2:  193:	PointListNode *node = *pll, *last = NULL;
       27:  194:	while (node != NULL) {
       23:  195:		last = node;
       23:  196:		node = node->next;
       23:  197:		free(last);
        -:  198:	}
        2:  199:	free(pll);
        2:  200:}
