        -:    0:Source:../ssp.c
        -:    0:Programs:3
        -:    1:#ifndef SSP_H
        -:    2:#include "ssp.h"
        -:    3:#endif
        -:    4:
        -:    5:/**
        -:    6: * Check if two floats are equal (up to PRECISION)
        -:    7: */
    #####:    8:int floatequals(float f1, float f2) {
    #####:    9:	return fabs(f1 - f2) < PRECISION;
        -:   10:}
        -:   11:
        -:   12:/**
        -:   13: * Check if a float is positive (up to PRECISION)
        -:   14: */
      351:   15:int floatpos(float f) {
      351:   16:	if (f > 0) {
      309:   17:		return 1;
        -:   18:	}
       42:   19:	return f > -PRECISION;
        -:   20:}
        -:   21:
        -:   22:/**
        -:   23: * Initialize the dynamic array of DZs in the SSP
        -:   24: */
        1:   25:void makedzs(SSP *ssp, size_t size) {
        1:   26:	ssp->zones = size;
        1:   27:	ssp->dzs = (DemandZone*) calloc(size, sizeof(DemandZone));
        1:   28:}
        -:   29:
        -:   30:/**
        -:   31: * Returns a pointer to a new (empty) SSP
        -:   32: */
        1:   33:SSP* newssp() {
        1:   34:	SSP *ssp = (SSP*) calloc(1, sizeof(SSP));
        1:   35:	return ssp;
        -:   36:}
        -:   37:
        -:   38:/**
        -:   39: * Print a DZ to stdout
        -:   40: * Not used in current implementation, but could be useful
        -:   41: */
    #####:   42:void printdz(DemandZone *dz) {
    #####:   43:	printf("DZ: x = %f, y = %f, w = %f, h = %f, v = %f\n", dz->x, dz->y, dz->w, dz->h, dz->v);
    #####:   44:}
        -:   45:
        -:   46:/**
        -:   47: * Print an SZ to stdout
        -:   48: */
        1:   49:void printsz(ServiceZone *sz) {
        1:   50:	printf("SZ: x = %f, y = %f, w = %f, h = %f\n", sz->x, sz->y, sz->w, sz->h);
        1:   51:}	
        -:   52:
        -:   53:/**
        -:   54: * Calculate the reward for an SZ with respect to a specific DZ
        -:   55: */
      176:   56:float reward(ServiceZone *sz, DemandZone *dz) {
      176:   57:	float w = fmin(sz->x + sz->w, dz->x + dz->w) - fmax(sz->x, dz->x);
      176:   58:	float h = fmin(sz->y + sz->h, dz->y + dz->h) - fmax(sz->y, dz->y);
      176:   59:	if (!floatpos(w) || !floatpos(h)) {
       23:   60:		return 0;
        -:   61:	}
      153:   62:	return dz->v * w * h;
        -:   63:}
        -:   64:
        -:   65:/**
        -:   66: * Set the SSP up to be solved by calculating the list of inner y-points,
        -:   67: * the list of x points, a map which maps a point to associated indices of a
        -:   68: * DZ for which it is an inner point, and a map which maps a point to the
        -:   69: * associated indices of the DZs for which it is an outer point
        -:   70: */
        1:   71:void setup(SSP *ssp, PointList *yi, PointList *l, IndexMap *ix, IndexMap *ox) {
        1:   72:	float ws = ssp->sz.w, hs = ssp->sz.h, wd, xd;
        1:   73:	PointListNode *cur = NULL;
        1:   74:	IndexMapping *mapping = NULL;
        6:   75:	for (int i = 0; i < ssp->zones; i++) {
        -:   76:		// Add the interior y-values
        5:   77:		pladd(yi, ssp->dzs[i].y);
        5:   78:		pladd(yi, ssp->dzs[i].y + ssp->dzs[i].h - hs);
        5:   79:		cur = *l;
        -:   80:		// Add the interior and exterior x-values
        5:   81:		xd = ssp->dzs[i].x;
        5:   82:		wd = ssp->dzs[i].w;
        5:   83:		pladd(l, xd - ws);
        5:   84:		pladd(l, xd);
        5:   85:		cur = pladd(l, xd + wd - ws);
        5:   86:		pladd(l, xd + wd);
        -:   87:		// Add to interior mapping
        5:   88:		imadd(ix, ssp->dzs[i].x, i);
        5:   89:		imadd(ix, ssp->dzs[i].x + ssp->dzs[i].w - ws, i);
        -:   90:		// Add to exterior mapping
        5:   91:		imadd(ox, ssp->dzs[i].x - ws, i);
        5:   92:		imadd(ox, ssp->dzs[i].x + ssp->dzs[i].w, i);
        -:   93:	}
        1:   94:}
        -:   95:
        -:   96:/**
        -:   97: * Calculate the solution to a given SSP.  The SZ of the SSP input will be
        -:   98: * modified so that its coordinates are the optimal coordinates.  Returns the
        -:   99: * total reward of the SZ
        -:  100: */
        1:  101:float solvessp(SSP *ssp) {
        1:  102:	ServiceZone *sz = &(ssp->sz);
        1:  103:	PointList *yis = newpl(), *l = newpl();
        1:  104:	IndexMap *ix = newim(), *ox = newim();
        1:  105:	setup(ssp, yis, l, ix, ox);
        1:  106:	float c = 0, y, phi, m, lk, ws = ssp->sz.w, xs, ys;
        1:  107:	PointListNode *ycur = *yis, *xcur = NULL;
        -:  108:	IndexList oind, iind;
       11:  109:	while (ycur != NULL) {
        9:  110:		y = ycur->value;
        9:  111:		sz->y = y;
        9:  112:		phi = 0;
        9:  113:		m = 0;
        9:  114:		xcur = *l;
      135:  115:		while (xcur->next != NULL) {
      117:  116:			lk = xcur->value;
      117:  117:			oind = evaluate(ox, lk);
      315:  118:			while (oind != NULL) {
       81:  119:				sz->x = ssp->dzs[oind->value].x;
       81:  120:				m += reward(sz, &(ssp->dzs[oind->value])) / ws;
       81:  121:				oind = oind->next;
        -:  122:			}
      117:  123:			iind = evaluate(ix, lk);
      324:  124:			while (iind != NULL) {
       90:  125:				sz->x = ssp->dzs[iind->value].x;
       90:  126:				m -= reward(sz, &(ssp->dzs[iind->value])) / ws;
       90:  127:				iind = iind->next;
        -:  128:			}
      117:  129:			phi += m * (xcur->next->value - lk);
        -:  130:			// printf("(%.3f, %.3f): %.3f\n", xcur->next->value, y, phi);
      117:  131:			if (c < phi) {
        9:  132:				c = phi;
        9:  133:				xs = xcur->next->value;
        9:  134:				ys = y;
        -:  135:			}
      117:  136:			xcur = xcur->next;
        -:  137:		}
        9:  138:		ycur = ycur->next;
        -:  139:	}
        1:  140:	sz->x = xs;
        1:  141:	sz->y = ys;
        1:  142:	plfree(yis);
        1:  143:	plfree(l);
        1:  144:	imfree(ix);
        1:  145:	imfree(ox);
        1:  146:	return totalreward(ssp);
        -:  147:}
        -:  148:
        -:  149:/**
        -:  150: * Deallocate an SSP and the associated list of DZs
        -:  151: */
    #####:  152:void sspfree(SSP *ssp) {
    #####:  153:	free(ssp->dzs);
    #####:  154:	free(ssp);
    #####:  155:}
        -:  156:
        -:  157:/**
        -:  158: * Check that two SZs are equivalent
        -:  159: */
    #####:  160:int szequals(ServiceZone *sz1, ServiceZone *sz2) {
    #####:  161:	return floatequals(sz1->x, sz2->x) && floatequals(sz1->y, sz2->y) && floatequals(sz1->w, sz2->w) && floatequals(sz1->h, sz2->h);
        -:  162:}
        -:  163:
        -:  164:/**
        -:  165: * Calculate the total reward recieved by the SZ in a given SSP
        -:  166: */
        1:  167:float totalreward(SSP *ssp) {
        1:  168:	float t = 0;
        6:  169:	for (int i = 0; i < ssp->zones; i++) {
        5:  170:		t += reward(&(ssp->sz), &(ssp->dzs[i]));
        -:  171:	}
        1:  172:	return t;
        -:  173:}
